# -*- coding: utf-8 -*-
"""HydrophoneMain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16CpLtS69x2GGMna83JIOXpLHDfX5xvu6
"""

import math
#import numpy as np
#import matplotlib.pyplot as plt
#import pandas as pd
#import csv

"""New Field Deployment File for Sound Sensor

"""

"""Field Deployment File"""

#----------------------------------------------------------------------------
# OCN n61 basic temperature instrument code
#
# Sensor field deployment code
# - Samples and save temperatures data with a time stamp
# - Saves a .csv data file
# 
#----------------------------------------------------------------------------
"""
How to use this code:
To sample continuously with sleep cycle connect Pin 16 to RST
To test code but not enter sleep cycle, connect Pin 16 to Pin 2 (GND)
This code establishes the function sample_sound() which takes three arguments:
- sleep_flag          
- sample_interval_sec 
- depth               
"sleep_flag" sets whether your sensor sleeps: 1 --> sleep; 0 --> no sleep 
(ex:sleep_flag = 0)
"sample_interval_sec" sets the number of seconds between desired temp readings (ex:
sample_interval_sec=5*60)
"depth" lets you set the depth at which your sensor is located (ex: depth = 1.0)
default parameters are sleep_flag=0,sample_interval_sec=30, depth=1.0
#----------------------------------------------------------
Example usage (see below for additional parameter options):

>>>from hmain import sample_sound
>>>sample_sound()

These parameters should be set/modified in main.py to trigger automatic sampling 
upon wakeup
Use Pin 16 to control sleep mode:
    When Pin 16 is connected to RST, Pin 16 is pulled high. This condition must be 
met for the sensor to sleep
    If Pin 16 is disconnected from RST and connected to a GND pin, the sensor does 
not go to sleep.
"""

def sample_sound(sleep_flag=0,sample_interval_sec=30): #set this sample sleeping time
    from time import sleep_ms
    from machine import Pin, unique_id, I2C, RTC, DEEPSLEEP, deepsleep, ADC
    import urtc
    from gc import collect
    collect()
    # Assign Pin 16
    p16=Pin(16, mode=Pin.IN)
    # Check if Pin 16 is pulled low, if yes, put the instrument to sleep, if not keep going
    if p16.value()==0:
        sleep_flag=0
    
#-------------------------------------------------------------------------------
    # Set up the DS3231 external RTC
#-------------------------------------------------------------------------------
    p15 = Pin(15, Pin.OUT)  # Assign Pin 15 to power the DS3231 RTC
    p15.value(1)            # Set Pin 15 high
    i2c = I2C(scl = Pin(5), sda = Pin(4))   # Initalize the I2C pins
    rtc3231 = urtc.DS3231(i2c)              # Assign the DS3231
    
#-------------------------------------------------------------------------------
    # Set up the microphone
#------------------------------------------------------------------------------   
    #power microphone with gpio pin check with team about pin num
    p13 = Pin(13, Pin.OUT)
    p13.value(1)

    p12 = Pin(12, Pin.OUT) # set as ground pin
    p12.value(0)


    #set up adc pin
    adc = ADC(0)

#-------------------------------------------------------------------------------
    # Create the sleep cycle for the instrument
#-------------------------------------------------------------------------------   
    # Initialize onboard RTC
    rtc = RTC()
    # Set an interupt to wake up at the next sampling period
    rtc.irq(trigger=rtc.ALARM0, wake=DEEPSLEEP)
    rtc.alarm(rtc.ALARM0, 1000 * sample_interval_sec) 
    sleep_ms(1000)      # sleep for 1 s
                    
    #-------------------------------
    # Sample and save data
    #------------------------------- 

    print("starting to listen")
    

    DataToSave = "" #create list to save
    reps = 10   # number of reps in same sample
    volt_num = 50 # number of volts = length of listening (about 5 seconds)


    for i in range(reps):        
        t_external = rtc3231.datetime()  # Obtain current time

        # Create a formatted time stamp for the collected data
        timeStamp = str(str(t_external.year) + "-" + str(t_external.month) + "-" + str(t_external.day) + "-" + \
                    str(t_external.hour) + "-" + str(t_external.minute) + "-" + str(t_external.second))

        # listen for x num seconds
        vlist = []
        for i in range(volt_num):
          vlist.append(float(adc.read()/1024.))  


        vmin = min(vlist) #finds min value
        vmax = max(vlist) #finds max value
        a = vmax - vmin   #calculates amplitude
        
        m = sum(vlist) / len(vlist) #calculates mean
        v = sum(pow(x-m, 2) for x in vlist) / len(vlist) #calculates variance
        s = math.sqrt(v) #calculates standard deviation

        

        DataToSave += str(timeStamp) + ',' + str(a) + ',' + str(m) + ',' + str(s) + '\n'
        sleep_ms(500)    # pause for 1 sec

    print(DataToSave)
    
    # Saves list to the data file
    datafile = open("sound_data.csv",'a')
    datafile.write(DataToSave)
    datafile.close()
    
    print("\n")
    #----------------------------------
    # Close connections and hardware, and prepare to sleep 
    # Turn off power to sound sensor
    p13.value(0)
    # Turn off power to clock
    p15.value(0)
    # sleep for 5 sec
    sleep_ms(5000)
    # If in sleep_flag=1 and Pin 16 is connected to RST, go into deepsleep until the next sampling time.
    # If in sleep_flag=0 or Pin 16 is connected to GND, stop and wait for user to do something  
   
    if sleep_flag==1 and p16.value()==1:
        print('sleeping in 0.5 seconds...')
        sleep_ms(500)
        deepsleep()

"""# New Section"""
